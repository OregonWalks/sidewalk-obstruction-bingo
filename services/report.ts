import { DBSchema, IDBPDatabase, openDB } from 'idb';
import pushid from "pushid";
import { TileDetails } from "../components/gather-tile-details-modal";
import { TileInterface } from "./tiles";

interface ReportBase {
  /** Generated by pushid(). This makes it both probabilistically globally
   * unique and ascending by the time it was generated. */
  uuid: string;
  /** The time at which this report was queued. */
  addTime: Date;
  /** When the report last started being sent. If this is older than a
   * reasonable timeout, we should assume the send failed. */
  sending: Date | null;
  /** Currently the alt text of the tile. This should probably be something
 * more stable. */
  tile: string;

  /** Most reports are that someone found an obstruction, but if they un-mark a
   * tile after that tile was reported, we report a 'Cancel' update to undo it. */
  type: 'Found' | 'Cancel';
}
interface FoundReport extends ReportBase {
  type: 'Found';
  /** Extra information about this particular tile. */
  detail: string;
  /** The name of a location, as opposed to a geolocation. Either this or
   * lat/long/accuracy will be set. */
  textLocation: string | "";
  latitude: number | null;
  longitude: number | null;
  /** As in the Geolocation interface, the 95% confidence radius in meters. */
  accuracy: number | null;
}
interface CancelReport extends ReportBase {
  type: 'Cancel';
}

interface SobDB extends DBSchema {
  queuedReports: {
    key: string;
    value: FoundReport | CancelReport;
    indexes: {
      tile: string;
      addTime: Date;
    };
  };
}

const sobDB = (function (): Promise<IDBPDatabase<SobDB>> {
  if (typeof window !== 'undefined') {
    return openDB<SobDB>("sidewalk-obstruction-bingo", 1, {
      upgrade(db, oldVersion) {
        switch (oldVersion) {
          case 0: {
            const reportStore = db.createObjectStore('queuedReports', { keyPath: 'uuid' });
            reportStore.createIndex("tile", "tile");
            reportStore.createIndex("addTime", "addTime");
          }
        }
      },
      blocking() {
        // Everything should always be saved to IDB, and the system should only
        // notice that an upgrade is needed as another page is loaded, so we want to
        // get out of the way ASAP. Do that by immediately closing the database, and
        // then reload the page to get back in sync with the new code.
        sobDB.then(db => db.close());
        location.reload();
      },
    });
  }
  return Promise.reject(new Error("Don't use the database on the server."));
})();

/*
const reportAppScriptUrl =
  "https://script.google.com/macros/s/AKfycbwx-6aWGb_zojc9r-RGz84NGeTmWdv96ovuLOZQSNzRfyUxR2U/exec";

const productionSpreadsheet = "1oePSSxULfE4u1DZ2Gf91SkacNvYWXc_ZlbzEzntzlto";

const sendReportsDelay = 60 * 1000;
let sendReportsTaskId = -1;


function scheduleSendReports(): void {
  if (sendReportsTaskId === -1) {
    sendReportsTaskId = window.setTimeout(async () => {
      try {
        const db = await sobDB;
        const tx1 = db.transaction('reportsQueued', 'readonly');

        const reportTarget = new URL(reportAppScriptUrl);
        reportTarget.searchParams.append("sheet", productionSpreadsheet);
        const response = await fetch(reportTarget.href, {
          method: "POST",
        });

        sendReportsTaskId = -1;
      } catch (e) {
        sendReportsTaskId = -1;
      }
    }, sendReportsDelay);
  }
}*/

export async function queueReport(tile: TileInterface, { detailString, textLocation, location: { latitude, longitude, accuracy } }: TileDetails): Promise<string> {
  const db = await sobDB;
  const tx = db.transaction('queuedReports', 'readwrite');
  const uuid = pushid();
  await tx.store.add({
    uuid,
    addTime: new Date(),
    sending: null,
    type: 'Found',
    tile: tile.alt,
    detail: detailString,
    textLocation,
    latitude,
    longitude,
    accuracy,
  });
  return uuid;
}

export async function tryUnqueueReport(tile: TileInterface): Promise<void> {
  const db = await sobDB;
  const tx = db.transaction('queuedReports', 'readwrite');
  const lastMatchingReportCursor = await tx.store.index('tile').openCursor(tile.alt, 'prev');
  if (lastMatchingReportCursor === undefined || lastMatchingReportCursor.value.sending !== null) {
    // The 'Found' report was already sent, so add a 'Cancel' report.
    await tx.store.add({
      uuid: pushid(),
      addTime: new Date(),
      sending: null,
      type: 'Cancel',
      tile: tile.alt,
    });
  } else {
    // We caught it in time and can just delete the report.
    tx.store.delete(lastMatchingReportCursor.key);
  }
  console.log("Unqueue", { tile: tile.alt });
}
